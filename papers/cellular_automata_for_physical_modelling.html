<html>

<head>
<title>Cellular Automata for Physical Modelling</title>

<style>
<!--
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{text-align:center;
	font-size:18.0pt;
	font-weight:bold;}
h1
	{page-break-after:avoid;
	font-size:18.0pt;
	font-weight:bold;}
h2
	{page-break-after:avoid;
	font-size:14.0pt;
	font-weight:bold;}
-->
</style>

</head>

<body lang="EN-GB">

<p class="MsoTitle">Cellular Automata for Physical Modelling</p>

<h1>Introduction</h1>

<p>Current game environments are too static. The sorts of
things that move in games are restricted to either small, discrete objects such
as vehicles and people, or sometimes some larger, mechanical or pre-scripted
objects. In some cases, the water level in a container can move in scripted
ways, but it is only a single horizontal plane that moves up or down, and there
is no way for the player to directly interact with it.</p>

<p>A lot of real-life things are missing that are less
concrete, but nevertheless would play a large part in the sorts of environments
that games are set in.</p>

<ul>

<li>Fire that spreads, sets light to flammable objects, and damages
others.</li>

<li>Water that can be held in containers, flow through pipes, be
pumped around realistically, swum in, weigh objects down, overflow containers
and spread over floors and down slopes.</li>

<li>Oil that combines the fluid properties of water with the burning
properties of flammable materials such as wood.</li>

<li>Explosions that have realistic damage radii, doing more damage
indoors than outdoors, and travelling around corners in realistic ways.</li>

<li>Heat that causes air to rise, sets up convection currents, can be
pumped around by ventilation fans, and possibly even carry scents and smells.</li>

<li>Smoke and dust that spread with air currents, are generated by
fires or smoke grenades, and obscure vision and choke people.</li>

<li>Walls and environments that can be damaged, destroyed, set fire
to, moved, give limited protection from explosions and attacks and obscure
sight.</li>

</ul>

<p>Some of these features are in some games, but only in
heavily scripted and constrained ways – frequently they play little part in
actual gameplay, and so can look rather artificial – which of course is exactly
what they are. Using Cellular Automata (CA) to simulate these ideas can lead to
far more dynamic and realistic behaviour, and allow new types of gameplay and
new tactics within games. At the very least, they allow more realism, better
graphical rendering and so increase player immersion.</p>

<h1>CA Basics</h1>

<p>Cellular Automata (CA), and their close relatives Finite
Element Analysis (FEA) and Computational Fluid Dynamics (CFD) [CFD ref] are
already used in plenty of applications modelling air and water flow, heat
distribution, building stresses and strains, and many other aspects of the real
world. However, the main emphasis of the academic and commercial modellers is
accuracy. As games programmers, our only real concern is whether something
looks good enough and runs fast, and in almost every case, the simulation can
be enormously simplified while still looking perfectly correct to most people.</p>

<p>The basics of a CA are simple. The world is divided into a
grid of fixed-size cells. Each cell has various numbers associated with it to
represent its state. Usual values held in cells are the air pressure, temperature,
amount of water, which direction the water and/or air is flowing in, and so on.</p>

<p>Each game turn, every cell is processed, and it compares
itself with its neighbouring cells. Differences between them result in changes
to the state of the cell and/or its neighbours according to various laws. In
this article, these will be based very loosely on real physical laws. One of
the best-known CAs is “Conway’s Game of Life” [Conway ref]. This is an
extremely simple CA – it has a single bit of state – whether the cell is full
or not – and some extremely simple rules for changing state according to the
state of neighbouring cells. Nevertheless, even this incredibly simple model is
Turing-Machine-compatible [Conway Turing ref].</p>

<p>The CAs used in games will have rules based on various
physical models, and determine the amount of heat, air, water or smoke that is
transferred between neighbouring cells. Run the rules quickly enough on enough
cells, and water will flow downhill and find a level, gently heated air will
form convection currents, and strongly heated air will burn objects and in turn
be heated by the burning objects.</p>

<p>In a 3D array of cubic cells, there are three possible
definitions of “neighbour” cells:</p>

<ul>
<li>The 6 cells that share a face with the central cell.</li>
<li>Those 6, plus another 12 that share an edge with the central cell.</li>
<li>Those 18, plus another 8 that share a corner with the central cell.</li>
</ul>

<p>Surprisingly, the rules that are used for physics simulations
give almost the same sort of results, whichever of the three definitions we
use. Of course the first version is far simpler, and there is only one type of
neighbour cell, rather than three. For this reason, it is far easier to only
consider the 6 cells that share a face with the central cell to be neighbours.</p>

<p>The first thing to do is pick a physical size of a CA cell.
For human-sized games, we decided to use cubes that are half a metre across.
Any bigger, and a CA cell of air will not fit inside a narrow passageway.
Smaller cubes give higher resolution and allow smaller pipes, narrower gaps,
and so on – but the extra space and processing is expensive. Different scales
of games will naturally require a different size of CA cell, but because most
games are set at human scales, for convenience this article will assume a scale
of half-metre cube cells in its examples.</p>

<p>Another important consideration in a human-sized game is how
to model thin walls. Most internal house walls and doors are only a few
centimetres thick. They will stop water flow, and slow fire down, and stop
smoke &amp; air spreading, so they must be modelled in some way. Modelling them
conventionally by using many small cells, and marking those occupied by the
wall as solid, would require using cells of no more than about ten centimetres
across, which requires 125 times as many cells – an extremely expensive option.</p>

<p>Two possible solutions present themselves. One method, used
by the first in the X-Com series of games in their impressive and innovative
use of CAs [X-Com ref], is to model the faces between the cells as entities, as
well as the cells themselves. So walls, floors and ceilings always lie between
two cells, along cell faces. This works quite well, but it does mean that there
are now two distinct classes of object – things that fill a whole cube (rock,
dirt, furniture, tall grass); and things that sit between two cells (walls,
floorboards, short grass, doors). This creates annoying special cases in the
code used to model substances and their interactions, and causes code
replication between the two types, and debugging spaghetti. However, if this
model fits, then it is a viable one, and it is fairly intuitive – the internal
representation of objects matches their rendered shape fairly closely.</p>

<p>The other solution is one that retains its generality
without resorting to many tiny cells. This is far more flexible about where the
visual “edges” of the cells are in the world. Rather than the concept of a
fixed solid cubic cell, the edges between cells can move about a bit according
to the contents. This allows a thin wall to be chopped into half-metre squares,
and each square lives in a cell. Because the walls are only a few centimetres
thick, neighbouring cells are thought of as expanding to make up the extra
space. This “expansion” is simply a way of thinking about it – the CA code
itself does not know or care what shape the objects it represents are. As far
as the CA physics are concerned, everything is still half a metre thick. Most
of the work in making things look otherwise is in the rendering, rather than in
the CA routines. It is the job of the rendering to ensure that water goes all
the way to the wall’s mesh, and not just the edge of the CA cube, which would
leave a large gap.</p>

<p>In this scheme, a one-metre-wide corridor with thin wooden
walls is represented by a plane of “wood” cells, a plane of “air” cells, and
then a plane of “wood” cells. Since the centres of the cells are each half a
metre away from each other, the total width from wall to wall is still one
metre. Of course, the graphical representation of the world still shows that
the “cubes” of wood are not cubes at all but flat planes a few centimetres
thick, and this is the representation that will be used for any
collision-detection, but the distinction makes very little difference to the
things that are modelled with the CA – water, air, fire. Because these entities
are fairly amorphous, the difference between what is rendered and what is
actually being modelled is very hard for the player to see. Again, accuracy is
sacrificed for speed wherever the game can get away with it.</p>

<p>The next factor to consider is a gameplay decision – the
difference between using passive scenery and active scenery.</p>

<h2>Passive Scenery</h2>

<p>In this system, as far as the CA is concerned, the scenery
is inert. Water will flow around scenery; fire, air and heat will be stopped by
scenery. But the scenery is not affected by the actions of the CA in any way –
it does not burn, it does not get damaged, it does not get wet, or move in
currents. This is the simpler of the two representations, but still allows
discrete objects such as the ubiquitous oil drum and crate to float away on rivers
of water, or to explode or burn when heated by fire.</p>

<p>Because the CA only knows about cells, not polygons, the
scenery must be converted into a cell representation – usually as a
pre-processing step. These cells are simply marked as inert rock or similar,
and their only function is to ensure that water cannot flow into them, and that
heat is not exchanged with them. Of course, the scenery is usually a collection
of arbitrary polygons, and not aligned to cell boundaries at all, but the
things being modelled with CAs are so amorphous that this difference does not
matter in practice. As long as solid walls are represented by a continuous wall
of cells with no holes in it, water will not flow through and break the
illusion.</p>

<p>Even in this system, special cases should be made for doors
that can be opened, and other animating or moving objects. When doors are open,
they should remove (sliding doors) or move (swinging doors) the solid cells
that represent them, so that water and fire can move through them.</p>

<h2>Active Scenery</h2>

<p>The far more versatile, though also more adventurous option,
is to have the scenery modelled by the CA as well, and for fire, water and so
on to affect bits of the scenery. This also opens up the “totally destructible
world” concept that many are looking to as the next big thing in games, though
as with everything, there is nothing truly new in computer games [XCom ref
again].</p>

<p>In this system, rather than simply being cells of inert
material, scenery is modelled by its actual properties –current temperature,
how easily and fiercely it burns, how strong it is, and so on. As the cells of
the CA change their state according to the physical rules of the CA, so the
graphics engine changes how it renders the associated polygonal objects – they
become sooty, damaged, glow red hot, or (if the graphics engine can handle it)
they vanish altogether.</p>

<p>In the latter case, the graphics engine can either be of the
“Geo-Mod” type [Red Faction ref], or the object itself can simply have been
specially marked as destructible, such as a thin wooden wall, and have an
alternative “broken” representation, as done by current engines when dealing
with damage by weapon fire.</p>

<h1>The Octree</h1>

<p>Those considering implementing these CA methods will have
quickly noticed that storing half-metre cells for even a modestly-sized level
consumes a huge amount of memory, and the processing and memory-bandwidth
requirements become severe. The trick is to not store or process cells that are
not participating in any interesting activities – notably inert walls, and air
at ambient or “standard” temperature and pressure (STP).</p>

<p>An octree is ideally suited to storing this arrangement,
specifically a dynamically-allocated octree. In any implementation of the
octree, remember that by far the most common operation in a CA is “find the
cell next to this one”, so optimising for this type of operation when
implementing the octree will pay off in terms of speed. If this request is
made, and there is no neighbouring cell in the octree, it is assumed that the
neighbouring cell is air at standard temperature and pressure. The physical
simulations are carried out accordingly, and if they result in the “missing”
cell becoming significantly different from standard temperature and pressure, a
cell with the new properties is created and inserted in the octree. When an air
cell returns to within a certain tolerance of standard temperature and
pressure, it is deleted from the octree and is no longer processed.</p>

<p>The octree holding CA cells can also be useful as a general-purpose
octree. Many games use octrees to optimise collision detection and culling when
rendering (e.g. frustum culling), and there is no reason this one cannot fulfil
both roles, and hold objects not directly related to the CA. A fairly easy
adaptation to the search algorithms allows the octree to become a “loose
octree,” [ref Thatcher Ulrich] which has several other advantages over a
conventional octree. This does not change its behaviour when dealing with the
CA aspect of its behaviour, since all CA cells are aligned to regular intervals
and have a fixed size.</p>

<h1>Practical Physics</h1>

<p>The main thing to remember when writing CA physics routines
is to keep things simple. It is surprisingly easy to write very simple routines
that look perfectly good to the eye, despite taking major physical shortcuts.
As long as the basics of conservation of mass and energy are retained (and the
latter is frequently optional), most of the other code deals with keeping the
simulations stable, ensuring that numbers do not spiral out of control and
become very small or (usually worse) very large.</p>

<p>The major problem encountered during implementation was
finding good simple models of the various physical features. Most of the
standard references deal with the application of Navier-Stokes equations for
various materials, and implementing them with as little error as possible. This
enormously complicates the code, and most of the academic and commercial
literature is concerned with these error reductions. For games, what is
required is simplicity, not accuracy. Most of the time, finding implementations
involved getting the general feel of the behaviour from the literature, then
writing something only vaguely approximating it.</p>

<h1>Core Processing Model</h1>

<p>Most of the properties simulated by the CA work in similar
ways. To illustrate these common methods, here is a very simple fluid
simulation that simply tries to achieve even distribution of pressure
throughout the available space. Even this simple model is very useful for air
and fluid modelling, even though it misses out some major features of real
gasses and fluids.</p>

<pre>
for ( neigh = each neighbour cell )
{
    if ( neigh-&gt;Material-&gt;IsInert() )
    {
        continue;
    }
    float DPress = cell-&gt;Pressure – neigh-&gt;Pressure;
    float Flow = cell-&gt;Material-&gt;Flow * DPress;
    Flow = clamp ( Flow, cell-&gt;Pressure / 6.0f, -neigh-&gt;Pressure / 6.0f );
    cell-&gt;NewPressure -= Flow;
    neigh-&gt;NewPressure += Flow;
}
</pre>

<p>The clamp() operation is performed to prevent NewPressure
going negative. The division by six is because there are six neighbour cells.
In practice, even more damping may be needed to retain stability, and prevent
numbers going negative, and small oscillations (e.g. waves on the surface of
water) becoming large, unrealistic oscillations.</p>

<p>Conventionally, once all the cells have been processed in
this way, for each cell, all the NewPressure values are copied to the Pressure
values. This double-buffering is necessary, rather than simply writing directly
to Pressure at the end of the routine, otherwise pressure will be transmitted
extremely fast (sometimes instantly) in the direction that the cells are
visited during an update cycle, and much slower in the reverse directions. This
produces asymmetry in heat distribution, water flow and other processes, and
the effect is very obvious to players.</p>

<p>The double visit to each cell can hurt performance
considerably, especially as the second visit is simply a copy, and will be
limited by memory bandwidth on most modern CPUs. A better method is to store the
last turn that a cell was processed. When subsequently processing that cell,
the turn number is checked, and if it is earlier than the current turn, the
copy is done. Although slightly odd-looking, this is in fact much quicker than
scanning the whole array of cells twice. The code becomes:</p>

<pre>
if ( cell-&gt;Turn != CurrentTurn )
{
    cell-&gt;Turn = CurrentTurn;
    cell-&gt;Pressure = cell-&gt;NewPressure;
}
for ( neigh = each neighbour cell )
{
    if ( neigh-&gt;Material-&gt;IsInert() )
    {
        continue;
    }
    if ( neigh-&gt;Turn != CurrentTurn )
    {
        neigh-&gt;Turn = CurrentTurn;
        neigh-&gt;Pressure = neigh-&gt;NewPressure;
    }
    // ... same physics code as before ...
}
</pre>

<h1>Air</h1>

<p>The above simple model works well for uniform redistribution
of air pressure. At first glance, this is not something that is frequently
modelled in games, but in fact it is one of the commonest effects – explosions,
and their effects on things. An explosive is simply a lump of material that
produces a huge amount of air in a very short time. They can be modelled by
finding the nearest CA cell to the centre of an exploding grenade, and adding a
large number to the cell’s pressure, then letting the CA propagate the pressure
through the world. Damage is done to the surroundings by either high absolute
pressures or high pressure differences – in reality both do different sorts of
damage to different objects, but that is usually unnecessary complication for
the purposes of a game.</p>

<p>The advantages of this method of modelling over conventional
ones is that line-of-sight modelling is handled automatically. Explosions in
confined spaces are far more deadly at a certain range than explosions in open
spaces, because there is less space for the pressure to dissipate. In addition,
it shows that pure line-of-sight is not protection enough from explosions –
they do go around corners and obstructions to a certain degree.</p>

<p>Because the simulation of the flow of air is qualitatively
correct to the human eye, debris and small objects can be carried along with
the explosion, without having to worry about the illusion being shattered by
debris going the wrong way, or through solid walls.</p>

<h1>Water</h1>

<p>Water is only slightly more complex than air. The obvious
distinction is that air expands to fill the available space with cells changing
pressure to do so, while water stays at the bottom of its container, and is
incompressible.</p>

<p>In fact, the easiest way to simulate the transmission of
pressure through water is to make it slightly compressible. This means pressure
can be stored as a slight excess mass of water in the cell, above what the
cell’s volume should be able to hold. In practice, the amount of compression
needed is tiny – allowing just 1% more water per cell per cube height is easily
enough. In a static body of water whose cells can normally contain one litre of
water each, the cells at the top will contain one litre, the ones under them
will contain 1.01 litres, the cells under those will contain 1.02 litres, and
so on to the bottom. This tiny amount of compression will be completely unnoticeable
to the player, but has enough dynamic range to allow all the usual properties
of liquids. For example, the levels of water in two containers joined by a
submerged pipe will be the same, even if water is poured into one of them – it
will flow through the pipe to the other container.</p>

<pre>
if ( neighbour cell is above this one )
{
    if ( ( cell-&gt;Mass &lt; material-&gt;MaxMass ) ||
         ( neigh-&gt;Mass &lt; material-&gt;MaxMass ) )
    {
        Flow = cell-&gt;Mass - material-&gt;MaxMass;
    }
    else
    {
        Flow = cell-&gt;Mass – neigh-&gt;Mass - material-&gt;MaxCompress;
        Flow *= 0.5f;
    }
}
else if ( neighbour cell is below this one )
{
    if ( ( cell-&gt;Mass &lt; material-&gt;MaxMass ) ||
         ( neigh-&gt;Mass &lt; material-&gt;MaxMass ) )
    {
        Flow = material-&gt;MaxMass - neigh-&gt;Mass;
    }
    else
    {
        Flow = cell-&gt;Mass – neigh-&gt;Mass + material-&gt;MaxCompress;
        Flow *= 0.5f; 
    }
}
else // neighbour is on same level
{
    Flow = ( cell-&gt;Mass – neigh-&gt;Mass ) * 0.5f;
}
</pre>

<p>This Flow value is then scaled and clamped according to some
measure of the maximum speed that the fluid can flow, allowing some fluids to
appear more viscous than others, and to prevent any resulting masses going
negative.</p>

<p>The two cases of code for both the up and the down case deal
with different situations. The first case is where one of the two cells is not
full of water – on the surface of a body of water, or if the water is splashing
or falling (for example, in a waterfall). Here, the behaviour is simple – water
flows downwards to fill the lower cell of the two to the value MaxMass – this
is the mass of water that can be contained by a single cell’s volume. In the
example above, the mass of 1 litre of water.</p>

<p>The second case is where both cells are full of water, or
perhaps a bit over-full. This is an area of water that is at pressure, and are
cells in the middle of a body of water. Here, the flow acts to try to make sure
that the upper cell has exactly MaxCompress more water than the lower cell.
MaxCompress is the amount of “extra” water that can be fitted in because of
compression – in the example above, it would be the mass of 0.01 litres of
water.</p>

<h1>Flow</h1>

<p>So far the air and water models have ignored a fairly
important property of any liquid or gas – its speed of flow. It has  simply
taken the difference in pressures between two cells, and used that to move mass
around. This is fine for relatively static environments that we wish to bring
to a stable state (uniform air pressure, or water finding its level). Many
games will only use these simple properties for all the gameplay and realism
they need.</p>

<p>However, what happens in real life is that water and air
have momentum (which equals flow times mass), and the difference in pressure
only influences the flow between cells, it does not rigidly set it. Storing
momentum or flow is important when modelling waves, flowing rivers and air
currents. Although rivers can flow in models without momentum, they usually 
have a very visible slope, which looks very bizarre.</p>

<p>To model momentum (or, alternatively, speed of flow), each
processing step, the difference in masses determines the pressure gradient, as
before. However, instead of changing the masses of the cells directly, the
pressure gradient only alters the flow between the cells. The flow then changes
the masses in the cells. The code is slightly more complex, as flow is a
three-dimensional vector, and not a scalar like mass.</p>

<p>There are two possible ways to think about flow. The first
is to think of a flow vector as being the flow through the centre of the cell.
This is possibly the most intuitive model – the flow and the mass of the cell
are both measured at its centre. However, in this case, the flow is affected by
the pressure differential between the two neighbouring cells, and in turn
determines how mass flows from one neighbouring cell to the other. Note the
slightly odd result that for a particular cell, the flow stored in it is not
affected by the mass in the cell itself (only its neighbours), nor does it
change the mass of the cell (only its neighbours). This is a slightly
surprising result, and in some cases can lead to some odd behaviour.</p>

<p>The more useful model is to think of each component of the
flow vector as being the flow between two adjacent nodes – from the “current”
node to the node in the positive relevant direction. Thus the flow vector F
stored at cell (x,y,z) has the meaning that F.x is the flow from cell (x,y,z)
to cell (x+1,y,z); F.y is the flow from cell (x,y,z) to cell (x,y+1,z); and
similarly for F.z. The “meaning” of the vector F is now not as intuitive, but
the physical model does seem more sensible. In practice, this is the most
common model, but either model can be used for simulation with appropriate
adjustment of the various constants.</p>

<p>The most important thing in this model is to keep a very
firm grip on oscillations. Not only does this model allow waves, it tends to
encourage them to build up, and sufficient damping must be applied to the flow
(i.e. friction), otherwise waves can build up higher and higher instead of
dying down, and the liquid or gas starts to do very odd things indeed.</p>

<p>It is worth mentioning that although one of the most common
applications of flow is in rivers, in most “human-sized” games, large bodies of
water such as lakes and rivers are frequently far too large to participate in
gameplay. Their behaviour will stay fairly constant whatever the player does,
and if they do change, they will do so in highly constrained ways. They do not
usually require the flexibility of a CA, and are often far better modelled and
rendered in more conventional ways – pre-animated meshes and collision models,
and scripted events. However, there are many other genres that operate on
larger scales and will want to properly simulate rivers with a CA.</p>

<h1>Heat</h1>

<p>Transmitting heat through the environment, whether from
burning objects or from other sources, happens through three separate
mechanisms – conduction, convection and radiation.</p>

<h2>Conduction</h2>

<p>Conduction is the simplest to simulate. Neighbouring cells
pass heat energy between each other so that eventually they reach the same
temperature as each other. This is complicated because different materials are
heated by different amounts by the same amount of energy – called the Specific
Heat Capacity (SHC – usually measured in J/kg°C).
If a hot cell made of water (high SHC, hard to heat up) is next to a colder
cell made of the same mass of iron (low SHC), equilibrium will be reached at
somewhere very close to the original temperature of the water, not at the
average of the two temperatures. This is because when a given amount of energy
is transferred from the water to the iron, the water’s temperature drops far
less than the iron’s temperature rises.</p>

<p>Note that the above example is true for the same <i>mass</i>
of each substance. However, iron has a far greater density than water, and
therefore for the same <i>volume</i>, they have very similar heat capacities.</p>

<pre>
// Find current Heat Capacities.
float HCCell = cell-&gt;material-&gt;SHC * cell-&gt;Mass;
float HCNeigh = neigh-&gt;material-&gt;SHC * neigh-&gt;Mass;
float EnergyFlow = neigh-&gt;Temp - cell-&gt;Temp;
// Convert from heat to energy
if ( EnergyFlow &gt; 0.0f )
{
    EnergyFlow *= HCNeigh;
}
else
{
    EnergyFlow *= HCCell;
}

// A constant according to cell update speed.
// Usually found by trial and error.
EnergyFlow *= ConstantEnergyFlowFactor;
neigh-&gt;Temp -= EnergyFlow / HCNeigh;
cell-&gt;Temp += EnergyFlow / HCCell;

// Detect and kill oscillations.
if (((EnergyFlow&gt;0.0f)&amp;&amp;(neigh-&gt;Temp&lt;cell-&gt;Temp))||
    ((EnergyFlow&lt;=0.0f)&amp;&amp;(neigh-&gt;Temp&gt;cell-&gt;Temp)))
{
    float TotalEnergy = HCCell * cell-&gt;Temp +
                        HCNeigh * neigh-&gt;Temp;
    float AverageTemp = TotalEnergy / ( HCCell + HCNeigh );
    cell-&gt;Temp = AverageTemp;
    neigh-&gt;Temp = AverageTemp;
}
</pre>

<p>The code at the end is necessary if two materials with very
different SHCs are side by side – the temperatures of the two can oscillate
violently, and can grow out of control. The physically correct solution is to
integrate the transfer of heat over time. However, this approach simply finds
the weighted average temperature (i.e. the temperature that the system would
reach eventually). It is less accurate, but looks perfectly good to the eye,
and is quite a bit quicker to execute. Importantly, it obeys the conservation
of energy, so any artefacts are purely temporary – the longer-term state is the
same as a more realistic simulation.</p>

<h2>Convection</h2>

<p>Convection is the phenomenon of heat rising. Hot areas of
fluid (air, water or otherwise) are less dense than cold areas, and thus try to
rise. This can be simulated by incorporating temperature into the model of
water or air. If using a flow model, the flow will be influenced by the
relative temperatures of cells as well as their relative pressures. If not
using a flow model, convection does not work very well, though its effects can
be faked as described below in the section on fire.</p>

<h2>Radiation</h2>

<p>Hot things glow – they emit light at various wavelengths
which travels in straight lines, hits other surfaces, and in turn heats them
up. This effect is very important physically, but unfortunately is also
extremely expensive to model. Each source of heat must effectively shoot many
rays out from itself and heat up whatever they hit.</p>

<p>Radiative heat modelling is very similar to the radiosity
modelling that is used when creating lightmaps for many current games. Both are
extremely expensive to model in runtime even crudely, though there are some
cunning methods that use a heavy amount of approximation to improve the speed
of radiative heat modelling. Even with these algorithms, modelling even a
fraction of the radiative heat seems like a prohibitive amount of work for a
game. These algorithms are also extremely complex, and do not involve the
standard cell-to-cell interactions that model all the other physical properties
mentioned – for both these reasons, they are well beyond the scope of this Gem.
The application of radiation to fire is discussed further below.</p>

<h1>Fire</h1>

<p>The physics of burning materials is frequently extremely
complex. There are multiple parts that burn at different rates and heats, and
there are also different phases of material involved in the process.</p>

<p>To perform the calculations in real-time, the material
models used need to be trimmed down to their minimum, and for each material, an
appropriate model chosen that emphasises the main characteristic.</p>

<p>Of many models considered, the one that finally seemed to give
best results for the least effort was a quadratic approximation of an
exponential graph. This graph shows how much heat energy is released per unit
time when a substance burns at a certain temperature. There is a maximum amount
of energy that can be released, no matter how hot the fire gets, but even at
relatively cool temperatures, a lot of heat is released. This explains why open
fires tend to start small, rapidly grow to a certain size, and then not grow
any bigger, but sit burning for a long time, despite there being plenty of fuel
available. They are simply not generating enough heat energy to compensate for
that lost to the environment (which is directly proportional to the
temperature).</p>


<pre>
float Temp = cell-&gt;Temp – material-&gt;Flashpoint;
if ( Temp < 0.0f )
{
    // Not burning.
    continue;
}

// Damage the cell.
CellDamage = Temp * material-&gt;BurnRate;
float Burn;
// Convert to actual burning value.
if ( Temp &gt; material-&gt;MaxBurn * 2 )
{
    Burn = material-&gt;MaxBurn;
}
else
{
    Burn = ( 1.0f - ( 0.25f * Temp / material-&gt;MaxBurn ) ) * Temp;
}
ASSE